#!/usr/bin/env bash
# Minimal, low-CPU dwlb status
# volume | âš¡ <RAPL1>W <RAPL0>W | ðŸ”¥ CPUÂ°C | ðŸ“ˆ CPU% (clickâ†’cpupower-gui) | ðŸ§  RAM | ðŸ’¾ HOME | ðŸ”‹ batt% ~h | ðŸ“… date ðŸ•’ time

set -u

LOOP_SLEEP=1     # refresh period (s) â€” tweak if you want snappier/slower
DISK_EVERY=60      # refresh disk usage every 60*LOOP_SLEEP seconds
TIME_EVERY=10      # refresh date/time every 10*LOOP_SLEEP seconds
BATT_EVERY=20      # refresh battery every 20*LOOP_SLEEP seconds

# ---------- helpers ----------
now_us() {
  # integer microseconds since epoch (bash 5: EPOCHREALTIME is "sec.usec")
  if [[ -n "${EPOCHREALTIME-}" ]]; then
    printf '%s' "${EPOCHREALTIME/./}"
  else
    printf '%s000000' "$(date +%s)"
  fi
}

read_uj() {  # read microjoules (int) or 0
  [[ -r "$1" ]] && { IFS= read -r v <"$1"; printf '%.0f' "${v:-0}"; } || printf '0'
}

# CPU % using /proc/stat (integer)
read_cpu_totals() {
  # fields: cpu user nice system idle iowait irq softirq steal guest guest_nice
  IFS=' ' read -r _ u n s i io ir so st _ _ < /proc/stat
  local idle=$((i + io))
  local total=$((u + n + s + i + io + ir + so + st))
  printf '%s %s\n' "$idle" "$total"
}

# Battery info (percent & eta hours) using /sys (no awk/bc)
# prints: "<pct> <hours_or_empty> <icon>"
battery_info() {
  local B="/sys/class/power_supply/BAT0"
  [[ -d "$B" ]] || { echo "??  ðŸ”‹"; return; }

  local pct status power_uW=0 en_uWh=0 ef_uWh=0 hours="" v
  [[ -r "$B/capacity" ]] && { IFS= read -r pct < "$B/capacity"; } || pct="??"
  [[ -r "$B/status"   ]] && { IFS= read -r status < "$B/status"; }   || status="Unknown"

  # Prefer energy_* (uWh) + power_now (uW)
  [[ -r "$B/energy_now"      ]] && { IFS= read -r v < "$B/energy_now";  en_uWh=${v%.*}; }
  [[ -r "$B/energy_full"     ]] && { IFS= read -r v < "$B/energy_full"; ef_uWh=${v%.*}; }
  (( en_uWh == 0 )) && [[ -r "$B/energy_now_uwh"  ]] && { IFS= read -r v < "$B/energy_now_uwh";  en_uWh=${v%.*}; }
  (( ef_uWh == 0 )) && [[ -r "$B/energy_full_uwh" ]] && { IFS= read -r v < "$B/energy_full_uwh"; ef_uWh=${v%.*}; }
  [[ -r "$B/power_now"       ]] && { IFS= read -r v < "$B/power_now";   power_uW=${v%.*}; }

  # Fallbacks via charge/current * voltage
  if (( en_uWh == 0 || ef_uWh == 0 )); then
    local qn=0 qf=0 vv=0 ia=0
    [[ -r "$B/charge_now"   ]] && { IFS= read -r v < "$B/charge_now";   qn=${v%.*}; }
    [[ -r "$B/charge_full"  ]] && { IFS= read -r v < "$B/charge_full";  qf=${v%.*}; }
    [[ -r "$B/voltage_now"  ]] && { IFS= read -r v < "$B/voltage_now";  vv=${v%.*}; }
    [[ -r "$B/current_now"  ]] && { IFS= read -r v < "$B/current_now";  ia=${v%.*}; }

    (( qn > 0 && vv > 0 )) && en_uWh=$(( (qn * vv) / 1000000 ))
    (( qf > 0 && vv > 0 )) && ef_uWh=$(( (qf * vv) / 1000000 ))
    (( power_uW == 0 && ia > 0 && vv > 0 )) && power_uW=$(( (ia * vv) / 1000000 ))
  fi

  if (( power_uW > 0 )); then
    if [[ "$status" == "Discharging" ]]; then
      # hours = en_uWh / power_uW  (fixed-point, 0.1h)
      local t10=$(( (en_uWh * 10 + power_uW/2) / power_uW ))
      hours=$((t10/10)).$((t10%10))
    elif [[ "$status" == "Charging" ]]; then
      if (( ef_uWh > en_uWh )); then
        local remain=$((ef_uWh - en_uWh))
        local t10=$(( (remain * 10 + power_uW/2) / power_uW ))
        hours=$((t10/10)).$((t10%10))
      fi
    fi
  fi

  local icon="ðŸ”‹"; [[ "$status" == "Charging" ]] && icon="ðŸ”Œ"
  if [[ -n "$hours" ]]; then
    echo "$pct ~${hours}h $icon"
  else
    echo "$pct  $icon"
  fi
}


# ---------- static paths ----------
PKG_CPU="/sys/class/powercap/intel-rapl/intel-rapl:0/energy_uj"  # RAPL0: CPU
PKG_SOC="/sys/class/powercap/intel-rapl/intel-rapl:1/energy_uj"  # RAPL1: SoC/platform

# CPU temp (coretemp Package id 0) â€” find once
find_cpu_temp() {
  for d in /sys/class/hwmon/hwmon*; do
    [[ -r "$d/name" ]] || continue
    IFS= read -r name < "$d/name" || continue
    [[ "${name,,}" == *coretemp* ]] || continue
    for lbl in "$d"/temp*_label; do
      [[ -r "$lbl" ]] || continue
      IFS= read -r l < "$lbl" || continue
      [[ "$l" == "Package id 0" ]] || continue
      echo "${lbl%_label}_input"; return
    done
    for ti in "$d"/temp*_input; do [[ -r "$ti" ]] && { echo "$ti"; return; }; done
  done
  echo ""
}
CPU_TEMP_PATH="$(find_cpu_temp)"

# ---------- initial baselines ----------
prev_cpu_uj=$(read_uj "$PKG_CPU")
prev_soc_uj=$(read_uj "$PKG_SOC")
prev_us=$(now_us)
read prev_idle prev_total < <(read_cpu_totals)

# slow-changing caches
disk_str=""; time_str=""; batt_str=""
tick=0

# ---------- main loop ----------
while :; do
  tick=$((tick+1))

  # Volume (pamixer spawns once per loop)
  mute="false"; vol="0"
  mute="$(pamixer --get-mute 2>/dev/null || echo false)"
  vol="$(pamixer --get-volume 2>/dev/null || echo 0)"
  [[ "$mute" == "true" ]] && vol_text="ðŸ”‡ mute" || vol_text="ðŸ”Š ${vol}%"
  vol_block="^lm(pamixer -t)^su(pamixer -i 5)^sd(pamixer -d 5)${vol_text}^sd()^su()^lm()"

  # RAPL power (no sleeps): W = Î”Î¼J / Î”Î¼s
  cur_cpu_uj=$(read_uj "$PKG_CPU")
  cur_soc_uj=$(read_uj "$PKG_SOC")
  cur_us=$(now_us)
  dus=$((cur_us - prev_us)); (( dus <= 0 )) && dus=1
  d_cpu=$((cur_cpu_uj - prev_cpu_uj)); (( d_cpu < 0 )) && d_cpu=0
  d_soc=$((cur_soc_uj - prev_soc_uj)); (( d_soc < 0 )) && d_soc=0
  # fixed-point 0.1W
  cpu_w10=$(( (d_cpu * 10 + dus/2) / dus ))
  soc_w10=$(( (d_soc * 10 + dus/2) / dus ))
  prev_cpu_uj=$cur_cpu_uj; prev_soc_uj=$cur_soc_uj; prev_us=$cur_us
  power_str="^fg(FFD700)âš¡^fg() $((soc_w10/10)).$((soc_w10%10))W $((cpu_w10/10)).$((cpu_w10%10))W"

  # CPU temp
  if [[ -n "$CPU_TEMP_PATH" && -r "$CPU_TEMP_PATH" ]]; then
    IFS= read -r t_milli < "$CPU_TEMP_PATH" || t_milli=0
    cpu_c=$((t_milli/1000))
  else
    cpu_c="?"
  fi
  temp_str="ðŸ”¥ ${cpu_c}Â°C"

  # CPU load %
  read cur_idle cur_total < <(read_cpu_totals)
  d_tot=$((cur_total - prev_total)); d_idl=$((cur_idle - prev_idle))
  prev_total=$cur_total; prev_idle=$cur_idle
  cpu_pct=$(( d_tot>0 ? ( (d_tot - d_idl) * 100 / d_tot ) : 0 ))
  cpu_block="^lm(cpupower-gui)ðŸ“ˆ ${cpu_pct}%^lm()"

  # RAM (MemAvailable)
  mem_total_kb=0; mem_avail_kb=0
  while IFS=' ' read -r k v _; do
    case "$k" in
      MemTotal:)     mem_total_kb=$v ;;
      MemAvailable:) mem_avail_kb=$v ;;
    esac
    (( mem_total_kb && mem_avail_kb )) && break
  done < /proc/meminfo
  used_kb=$((mem_total_kb - mem_avail_kb))
  # 1 GiB = 1048576 KiB
  used_g10=$(( (used_kb*10 + 1048576/2) / 1048576 ))
  total_g10=$(( (mem_total_kb*10 + 1048576/2) / 1048576 ))
  ram_str="ðŸ§  $((used_g10/10)).$((used_g10%10))/$((total_g10/10)).$((total_g10%10))GiB"

  # Disk (HOME) â€” refresh infrequently
  if (( tick % DISK_EVERY == 1 )); then
    # df is heavier; run rarely
    disk_str="$(df -h "$HOME" --output=used,size 2>/dev/null | awk 'NR==2{print "ðŸ’¾ " $1 "/" $2}')"
    [[ -z "$disk_str" ]] && disk_str="$(df -h / | awk 'NR==2{print "ðŸ’¾ " $3 "/" $2}')"
  fi

  # Battery â€” refresh moderately
  if (( tick % BATT_EVERY == 1 )); then
    batt_str="$(battery_info)"
    # battery_info prints like: "85 ~3.7h ðŸ”‹"  or  "92  ðŸ”Œ"
    # Normalize to: "ðŸ”‹ 85% ~3.7h" or "ðŸ”Œ 92%"
    set -- $batt_str
    if [[ "$2" == "~"* ]]; then
      batt_str="${3} ${1} % ${2}"
    else
      batt_str="${2} ${1}%"
    fi
  fi

  # Date/time â€” refresh infrequently
  if (( tick % TIME_EVERY == 1 )); then
    dt="$(date '+%Y-%m-%d %H:%M')"
    time_str="ðŸ“… ${dt% *} ðŸ•’ ${dt#* }"
  fi

  bar=" ${vol_block} | ${power_str} | ${temp_str} | ${cpu_block} | ${ram_str} | ${disk_str} | ${batt_str} | ${time_str} "
  dwlb -status all "$bar"

  sleep "$LOOP_SLEEP"
done

